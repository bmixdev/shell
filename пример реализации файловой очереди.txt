Ниже — единый установочный пакет, который создаёт ВСЁ:

скрипт создания очереди (textqueue_mkqueue.sh)

скрипт записи (textqueue_write.sh)

скрипт чтения (textqueue_read_all.sh)

Ты запускаешь один файл, и после этого система полностью готова.

✅ Готовый единый установщик

Сохрани как install_textqueue.sh:

#!/bin/bash
set -e

# ===========================================================
#   ЕДИНАЯ УСТАНОВКА ФАЙЛОВОЙ ОЧЕРЕДИ
#   Создаёт 3 универсальных инструмента:
#     - textqueue_mkqueue.sh   (создать очередь + назначить пользователей)
#     - textqueue_write.sh     (писать сообщение в очередь)
#     - textqueue_read_all.sh  (читать все новые сообщения)
# ===========================================================

WRITE_SCRIPT="/usr/local/bin/textqueue_write.sh"
READ_SCRIPT="/usr/local/bin/textqueue_read_all.sh"
MKQUEUE_SCRIPT="/usr/local/bin/textqueue_mkqueue.sh"

echo "Устанавливаю файловую очередь…"
echo

# ===========================================================
#   textqueue_write.sh
# ===========================================================

cat > "$WRITE_SCRIPT" <<'EOF'
#!/bin/bash
# Универсальная запись сообщения в файловую очередь
# Использование:
#   textqueue_write.sh <queue_dir> "сообщение"
#   echo "лог" | textqueue_write.sh <queue_dir>

QUEUE_DIR="$1"
shift || true   # остальные аргументы — текст

if [ -z "$QUEUE_DIR" ]; then
    echo "Usage: $0 <queue_dir> [message...]" >&2
    exit 1
fi

mkdir -p "$QUEUE_DIR" 2>/dev/null || true
umask 0077

# Если stdin НЕ подключён — читаем аргументы
if [ -t 0 ]; then
    if [ $# -eq 0 ]; then
        echo "Нет данных: дай текст через stdin или аргументы" >&2
        exit 1
    fi
    tmp_file=$(mktemp "$QUEUE_DIR/.tmp.XXXXXX") || exit 1
    printf '%s\n' "$*" > "$tmp_file"
else
    # stdin подключён — читаем поток (можно огромный)
    tmp_file=$(mktemp "$QUEUE_DIR/.tmp.XXXXXX") || exit 1
    cat > "$tmp_file"
fi

if [ ! -s "$tmp_file" ]; then
    rm -f "$tmp_file"
    echo "Пустое сообщение, пропускаю" >&2
    exit 0
fi

ts=$(date +%s%N)
host=$(hostname -s 2>/dev/null || echo host)
pid=$$
final_file="$QUEUE_DIR/${ts}_${host}_${pid}.msg"

mv "$tmp_file" "$final_file"
exit 0
EOF
chmod +x "$WRITE_SCRIPT"


# ===========================================================
#   textqueue_read_all.sh
# ===========================================================

cat > "$READ_SCRIPT" <<'EOF'
#!/bin/bash
# Универсальное чтение ВСЕХ сообщений файловой очереди
# Использование:
#   textqueue_read_all.sh <queue_dir>
#   textqueue_read_all.sh <queue_dir> --raw

QUEUE_DIR="$1"
shift || true

if [ -z "$QUEUE_DIR" ]; then
    echo "Usage: $0 <queue_dir> [--raw]" >&2
    exit 1
fi

LOCK_FILE="$QUEUE_DIR/.lock"
MODE="pretty"

[ "$1" == "--raw" ] && MODE="raw"

mkdir -p "$QUEUE_DIR" 2>/dev/null || true

exec 9>"$LOCK_FILE"
flock -x 9

shopt -s nullglob
files=("$QUEUE_DIR"/*.msg)

(( ${#files[@]} == 0 )) && exit 0

IFS=$'\n' files_sorted=($(printf '%s\n' "${files[@]}" | sort))
unset IFS

for f in "${files_sorted[@]}"; do
    [ -f "$f" ] || continue

    case "$MODE" in
        pretty)
            echo "===== $(basename "$f") ====="
            cat "$f"
            echo
            ;;
        raw)
            cat "$f"
            echo
            ;;
    esac

    rm -f -- "$f"
done
EOF
chmod +x "$READ_SCRIPT"


# ===========================================================
#   textqueue_mkqueue.sh
# ===========================================================

cat > "$MKQUEUE_SCRIPT" <<'EOF'
#!/bin/bash
set -e

if [ "$EUID" -ne 0 ]; then
    echo "Этот скрипт должен запускаться от root." >&2
    exit 1
fi

QUEUE_DIR="$1"
QUEUE_GROUP="$2"
QUEUE_MODE="$3"
shift 3 || true

USERS=("$@")

if [ -z "$QUEUE_DIR" ] || [ -z "$QUEUE_GROUP" ] || [ -z "$QUEUE_MODE" ]; then
    echo "Usage: $0 <queue_dir> <group> <mode> <user1> [user2 ...]" >&2
    exit 1
fi

echo "=== Создание очереди ==="
echo "Каталог: $QUEUE_DIR"
echo "Группа:  $QUEUE_GROUP"
echo "Права:   $QUEUE_MODE"
echo "Пользователи: ${USERS[*]}"
echo

# 1. Создать группу (если нет)
if ! getent group "$QUEUE_GROUP" >/dev/null 2>&1; then
    groupadd "$QUEUE_GROUP"
    echo "[*] Создана группа $QUEUE_GROUP"
else
    echo "[=] Группа $QUEUE_GROUP уже существует"
fi

# 2. Создать каталог
mkdir -p "$QUEUE_DIR"

# 3. Права
chown root:"$QUEUE_GROUP" "$QUEUE_DIR"
chmod "$QUEUE_MODE" "$QUEUE_DIR"

# 4. Добавить пользователей в группу
for u in "${USERS[@]}"; do
    if id "$u" >/dev/null 2>&1; then
        usermod -aG "$QUEUE_GROUP" "$u"
        echo "[*] Пользователь $u добавлен в группу $QUEUE_GROUP"
    else
        echo "[!] Пользователь $u не существует"
    fi
done

echo
echo "Очередь создана!"
echo "Каталог: $QUEUE_DIR"
echo "Права:   $QUEUE_MODE root:$QUEUE_GROUP"
echo
echo "Важно: пользователи должны ПЕРЕЛОГИНИТЬСЯ, чтобы группа применилась."
echo
EOF
chmod +x "$MKQUEUE_SCRIPT"


# ===========================================================
echo
echo "=== УСТАНОВКА ЗАВЕРШЕНА ==="
echo "Доступные команды:"
echo "  textqueue_mkqueue.sh    – создать очередь и назначить пользователей"
echo "  textqueue_write.sh      – записать сообщение"
echo "  textqueue_read_all.sh   – прочитать все сообщения"
echo
echo "Пример создания очереди:"
echo "  sudo textqueue_mkqueue.sh /var/spool/queue_app1 queue_app1 770 user1 user2"
echo
echo "Пример записи:"
echo "  textqueue_write.sh /var/spool/queue_app1 \"Привет\""
echo "  echo \"лог\" | textqueue_write.sh /var/spool/queue_app1"
echo
echo "Пример чтения:"
echo "  textqueue_read_all.sh /var/spool/queue_app1"
echo "  textqueue_read_all.sh /var/spool/queue_app1 --raw"
echo

❗ Установка
chmod +x install_textqueue.sh
sudo ./install_textqueue.sh

✅ После установки: как работать
1) Создать очередь
sudo textqueue_mkqueue.sh /var/spool/myqueue myqueue 770 writer reader


Где:

/var/spool/myqueue — каталог очереди

myqueue — группа

writer — кто пишет

reader — кто читает

⚠️ writer / reader должны перелогиниться, чтобы группа обновилась.

2) Писать в очередь
textqueue_write.sh /var/spool/myqueue "Привет!"


или многострочный лог:

journalctl -u ssh.service | textqueue_write.sh /var/spool/myqueue

3) Читать очередь (удаляя сообщения)
textqueue_read_all.sh /var/spool/myqueue


или «сырой» вывод:

textqueue_read_all.sh /var/spool/myqueue --raw

Пример записи из Python:

✅ Вариант 1: передать текст как аргумент (для коротких сообщений)
import subprocess

queue_dir = "/var/spool/myqueue"
message = "Привет из Python!"

subprocess.run(
    ["/usr/local/bin/textqueue_write.sh", queue_dir, message],
    check=True
)


Но этот вариант не подходит для больших многострочных логов — аргументы командной строки ограничены (ARG_MAX) и нельзя передать бинарный контент.

✅ Вариант 2: передать лог через stdin (универсальный вариант, рекомендую)

textqueue_write.sh из нашего пакета полностью поддерживает stdin.
Пример:

import subprocess

queue_dir = "/var/spool/myqueue"

log_data = """
[INFO] Service started
[WARN] High memory usage
[ERROR] Something bad happened
"""

proc = subprocess.Popen(
    ["/usr/local/bin/textqueue_write.sh", queue_dir],
    stdin=subprocess.PIPE,
    text=True
)

proc.communicate(log_data)

Плюсы:

можно передать огромный лог (хоть 500 МБ)

не нужен экранирование

идеально для потока вывода приложения

безопасно

Если лог бинарный (не текстовый), используй:

proc = subprocess.Popen(
    ["/usr/local/bin/textqueue_write.sh", queue_dir],
    stdin=subprocess.PIPE
)
proc.communicate(b"\x01\x02\x03binary\x00log")

☑️ Вариант 3: удобная Python-функция-обёртка
import subprocess
from typing import Union

def queue_write(queue_dir: str, data: Union[str, bytes]):
    """Пишет строку или бинарные данные в очередь textqueue."""
    cmd = ["/usr/local/bin/textqueue_write.sh", queue_dir]

    if isinstance(data, str):
        p = subprocess.Popen(cmd, stdin=subprocess.PIPE, text=True)
        p.communicate(data)
    else:
        p = subprocess.Popen(cmd, stdin=subprocess.PIPE)
        p.communicate(data)

    if p.returncode != 0:
        raise RuntimeError(f"textqueue_write.sh exited with code {p.returncode}")


Использование:

queue_dir = "/var/spool/myqueue"

# строка
queue_write(queue_dir, "привет от python")

# многострочный лог
queue_write(queue_dir, "line1\nline2\nline3")

# бинарные данные
queue_write(queue_dir, b"\x00\x01binary")
